# Rails-like приложение

Привет, котятки! А давайте запилим приложение, похожее на типичный rails аппликейшн. Ну т.е. там будут MVC, роутинги, миграции, конфиги какие-то, всё как положено (или покладено, кому как больше нравится). Но сильно-сильно упрощенная версия любимого нашего фреймворка. Не будет генераторов и интерактивной консоли, красивых лейаутов и возни с ассетами. Короче, погнали!

## Rack
Начнем с того, что создадим пустую папку blog и будем в ней работать.

```bash 
$ mkdir blog
$ cd blog
$ touch Gemfile
$ subl .
```
Я люблю редактор sublime, поэтому у меня стоит alias на открытие этого редактора. `subl .` откроет редактор с этой папкой. В ней уже будет пустой Gemfile. С чего-то же надо начинать

```ruby
# Gemfile
source "https://rubygems.org"
ruby '2.3.1'
gem 'rack'
```

Итак, я подключил репозиторий гемов, указал версию руби и мне потребуется `gem 'rack'`. Rack предоставляет минималистичный интерфейс между веб-приложениями. Таким образом одно веб приложение может быть встроенно в другое, а другое в третье. 

Rack приложением может быть что угодно, что умеет отвечать на вызов `call` и возвращать массив из трех значений: 

1. статус
2. хеш хедеров
3. нечто, что можно иттерировать (отвечает на each)

Вот вам пример rack-аппликейшена

```ruby
app = Proc.new do |env|
    ['200', {'Content-Type' => 'text/html'}, ['A barebones rack app.']]
end
```
Proc умеет отвечать на вызов метода call, и вернет в данном случае строку статуса, хеш хедеров и массив с контентом.

Ну ок. Напишем тогда наш rack-аппликейшн:

```ruby
# app.rb
class App
  def call(env)
    [200, {}, ['Hello world']]
  end
end
``` 
Всем требованиям отвечает, теперь нужно сделать `config.ru` файл, который собственно и будет запускать наше приложение.

```ruby
#config.ru
require 'rubygems'
require 'bundler'
Bundler.require

require "./app"

run App.new
``` 
Ничего особенного тут не происходит. Подключаем рубигемс, подключаем бандлер, потом `Bundler.require` вычитывает наш `Gemfile` и подключает всё что в нем лежит. Потом мы подключаем наше приложение, которое лежит здесь же рядом в корне папки, и после мы запускаем его командой `run App.new`.

Ну всё! Приложение готово. Давайте запустим и проверим.

```bash
$ bundle install
$ rackup
```

Наше приложение поднялось и мы можем посмотреть не него вживую по адресу `http://localhost:9292`.

Так, быстренько, одно дополнение. Давайте в качестве апп-сервер вместо webrick использовать puma. Для этого допишем в Gemfile `gem 'puma'` и сделаем `$ bundle install`. Теперь при перезапуске приложения, rackup будет использовать puma. 


## Router
Простецкое приложение сделали. Оно всегда отвечает одним и тем же статусом, и одним и тем же "хеловорлдом". Поехали дальше. Нам нужно, чтобы по разным URL, были доступны разные страницы. В Rails это решается через роутинги. Именно в роутингах мы прописываем соответствие урла и обработчика. Будем использовать что-то похожее и у нас. И сразу два нововведения: всё что касается нашего "фреймворка" будем складировать в папку lib, всё что касается конечного приложения — в папку app.

Сначала изобразим некое подобие конфига роутингов и ОБМ я написал его в yaml'e.

```yaml
#./app/routes.yml
"/"     : "main#index"
"/hello": "main#hello"
"/posts": "posts#index"
``` 
Очень простое соответствие. Корневой урл ведет на MainController index-экшн. Нам нужно подключить этот конфиг в нашем приложении и я делаю это следующим образом.

```ruby
# app.rb
require 'yaml'
ROUTES = YAML.load(File.read(File.join(File.dirname(__FILE__), "app", "routes.yml"))) #1

require "./lib/router" # 2

class App
  attr_reader :router

  def initialize 
    @router = Router.new(ROUTES) # 3
  end

  def call(env)
    result = router.resolve(env) # 4
    [result.status, result.headers, result.content] # 5
  end
end
```

Что же я тут натворил, поэтапно:

1. Создаю константу ROUTES, в которую сохраняю хеш ключ-значений из нашего routes.yml файла
2. Подключаю класс роутера (его еще у нас нет, но это не значит, что мы не можем о нем думать)
3. Роутер создается во время инициализации приложения, получает на вход наш хеш роутингов и сохраняется в инстанс-переменную
4. В момент, когда происходит вызов call в env находится вся информация о запросе, в том числе о том, какой урл был указан. Поэтому здесь мы передаем эту информацию в наш роутер, чтобы он уже решил, что с ней делать. 
5. Ну и в конечном результате, нам нужно соответствовать Rack-интерфейсу, а следовательно мы вернем статус, хедеры и контент.

Остается написать сам класс роутера. И вот каким он будет:

```ruby
# ./lib/router.rb
class Router
  attr_reader :routes

  def initialize(routes)
    @routes = routes  # 1
  end

  def resolve(env)
    path = env['REQUEST_PATH'] # 2 
    if routes.key?(path) # 3 
      ctrl(routes[path]).call # 4
    else
      Controller.new.not_found # 5
    end
  rescue Exception => error
    puts error.message
    puts error.backtrace
    Controller.new.internal_error # 6
  end

  private def ctrl(string) 
    ctrl_name, action_name = string.split('#')
    klass = Object.const_get("#{ctrl_name.capitalize}Controller", Class.new)
    klass.new(name: ctrl_name, action: action_name.to_sym)
  end
end
```

А тут всё достаточно просто.
 
1. Сохранили значит наш хеш роутингов
2. Получаем путь из запроса
3. Если у нас по этому пути какое-то значение имеется,
4. то будем его обрабатывать, как полагается (подробно объясню ниже)
5. Если нет пути, то мы ответим 404 (Not Found)
6. А если случилась какая-то беда, то выведем в консольку информацию и будет отвечать 500 (Internal Server Error)

Что же происходит в пункте 4?
А вот что: мы находим в наших роутах значение по указанному урлу. Допустим, что это запрос на корень, то в наших routes.yml мы указали `"/"     : "main#index"`. А следовательно мы в качестве значения получаем `"main#index"`. 

Из этой строки нам нужно получить контроллер, но каким образом? Это делается в методе `def ctrl(string)`. 

1. Сроку `string` разбиваем по знаку решетки. Получаем два значения: имя контроллера, и имя экшена(`"main"` и `"index"`). 
2. Роутинги пишет пользователь нашего а-ля фреймворка, как и контроллеры. Поэтому мы из строки собираем имя контроллера (`MainController`) 
3. иницируем его (`MainController.new(name: "main", action: :index)`)
4. и в методе resolve делается call для этого контроллера.

Вот так быстро мы добрались до контроллеров. Продолжим?

## Оффтопик 1 

О! Теперь можно создать наш первый собственный контроллер

```ruby
# app/controllers/main_controller.rb
class MainController < Controller
  def index
    @test = "Some dump text here"
    @arr = %w(one two three)
  end
end
```
Мы не знаем, как пользователь нашей нехитрой библиотеки будет называть контроллеры. Их контроллеры будут наследоваться от нашего, но их все равно нужно подключить в наше приложение. Поэтому в app.rb допишем следующую строчку. А заодно сделаем такое же и для папки lib, чтобы не указывать отдельно, что подключить:

```ruby
# app.rb
Dir[File.join(File.dirname(__FILE__), 'lib', '*.rb')].each {|file| require file }
Dir[File.join(File.dirname(__FILE__), 'app', '**', '*.rb')].each {|file| require file }
...
```

## Controller

Так, что же нам нужно от контроллеров? Любой уважающий себя контроллер должен уметь отвечать на вызов call, знать своё имя и экшн, с которым будет вызван. 

Разбирая роутинги, я забыл упомянуть, но это видно из кода, именно объект контроллера будет возвращаться в наше приложение в result. 

```ruby
  def call(env)
    result = router.resolve(env)
    [result.status, result.headers, result.content]
  end
```
Помните? Вот тут роутер зарезолвил наш запрос и вернет нам в result контроллер. А дальше мы будем у него спрашивать про статус, хедеры и конент. ОК, приступим!

```ruby
# ./lib/controller.rb
class Controller
  attr_reader :name, :action
  attr_accessor :status, :headers, :content

  def initialize(name: nil, action: nil)
    @name = name
    @action = action # 1
  end

  def call
    send(action) # 2
    self.status = 200 # 3
    self.headers = {"Content-Type" => "text/html"}
    self.content = ["Hello world"]
    self
  end

  def not_found # 4
    self.status = 404
    self.headers = {}
    self.content = ["Nothing found"]
    self
  end

  def internal_error # 5
    self.status = 500
    self.headers = {}
    self.content = ["Internal error"]
    self
  end
end
```
Одна проза и никакой романтики:

1. Сохраняем экшн, который будет вызван
2. Собственно вызываем этот экшн
3. Исключительно из-за желания упростить, но получить работающий вариант, я говорю, что все успешные вызовы у нас будут со статусом 200, хедерами на HTML, а в теле будет уже всем надоевший "Hello world".
4. Сделал отдельный метод для не найдено. Вернуть мы должны именно контроллер, а не контент, поэтому `self` на конце
5. Такая же история и с пятисоткой. 

После всех этих манипуляций, при запуске приложения и переходу во пустому урлу, мы должны увидеть Hello world. Всё работает!

## Views
Еще немного доработаем напильником наш контроллер. В качестве шаблонизатора я выбрал Slim. Он очень просто прикручивается к нашему фреймворку:

```ruby
# GEmfile
...
gem 'slim'
```

```bash
$ bundle install
```
Далее мы контроллере изменим наш контент:

```ruby
# ./lib/controller.rb
  ...  
  def call
    send(action) # 1
    self.status = 200
    self.headers = {"Content-Type" => "text/html"}
    self.content = [template.render(self)] # 2
    self
  end
  
  def template # 3
    Slim::Template.new(File.join(App.root, 'app', 'views', "#{self.name}", "#{self.action}.slim"))  
  end
  ...
```
Пояснения:

1. Наш кастомный контроллер (MainController), когда произойдет вызов call, а соответственно будет выполнен метод index, определит несколько новых инстанс-переменных. Следуя нашему примеру, появятся новые переменные `@test` и `@arr`.
2. Именно для этого мы в наш шаблонизатор передаем сам инстанс контроллера. Таким образом определенные переменные в контроллере будут доступны из шаблона
3. В этом методе мы создаем сам объект шаблона, подтаскиваем нашу вьюшку для конкретно этого контроллера и этого экшене (`app/views/main/index.slim`)

Всё достаточно просто. Последнее, что осталось сделать, это добавить метод `root` в наше приложение. 

```ruby
# app.rb
...
class App
...
  def self.root
    File.dirname(__FILE__)
  end
end
```

Готово! Теперь мы можем прописывать свои роуты, делать минимальные контроллеры и рисовать вьюшки. Я вас категорически поздравляю, котятки.

## Model
Эй, ты еще здесь? Тебе что, интересно еще и про модели узнать?
Ну ладно, только чур, никакого ActiveRecord'a. Мы будем использовать замечательный гем, который может тоже самое и немного больше `sequel` и саму базу `sqlite`.

```
# Gemfile
...
gem 'sequel'
gem 'sqlite3'
```

Самое классное в нём, что нам не придется создавать какую-то нашу модель, от которой будут наследоваться другие модели. А потому сразу будем рассматривать на примере модели постов. В нашем `routes` файле уже есть запись про `"/posts" => "posts#index"`. А потому создадим контроллер, модель и вьюшку. 

```ruby
# ./app/models/post.rb
class Post < Sequel::Model(DB)
end
```
Типичная модель в rails-приложении (только наследуется от Sequel::Model). 

```ruby
# ./app/controllers/posts_controller.rb
class PostsController < Controller
  def index
    @posts = Post.all
  end
end
```
Типичный рельсовый контроллер, ни дать, ни взять.

```slim
/ ./app/views/posts/index.slim
- @posts.each do |post|
  h2 = post.title
  div = post.content
  hr
```
И простецкая вьюшка. А что собственно еще нужно?

А нужно вот что! Внимательный читатель увидел, что наследуем мы нашу модель от `Sequel::Model(DB)`. А в свою очередь константа `DB` у нас нигде не определена. О чем и скажет приложение при попытке запуска. Более того, что это за фреймворк, если мы нигде не определили конфиги доступа к базе данных. С этого и начнём:

```ruby
# app.rb
db_config_file = File.join(File.dirname(__FILE__), "app", "database.yml")
if File.exist?(db_config_file)
  config  = YAML.load(File.read(db_config_file))
  DB = Sequel.connect(config)
end
...

```  
Я опять дописал в app.rb небольшой кусок кода. Первая строчка проверяет есть ли файл конфига. Если есть то мы читаем файлик, парсим, создаем подключение к базе данных и сохраняем в контанту DB.  
А вот как будет выглядеть конфиг в нашем случае:

```yaml
# ./app/database.yml
adapter: sqlite
database: "./app/db/dev.sqlite3"
```

Логично, что нам нужно чтобы этот файл базы данных существовал. Выполним несколько команд.

```bash
$ mkdir -p app/db
$ touch app/db/dev.sqlite3
```

## Migrations
Осталось совсем немного. Посты у нас уже есть, но у нас нет ни таблицы, ни самих постов. Это решается не так уж сложно. Миграции будут запускаться автоматически в момент запуска приложения. Для этого нам понадобится экстеншн для Sequel'a. Добавим его одной строкой в блоке, где определяется коннект к базе данных.

```ruby
# Создаем коннект к базе
db_config_file = File.join(File.dirname(__FILE__), 'app', 'database.yml')
if File.exist?(db_config_file)
  config  = YAML.load(File.read(db_config_file))
  DB = Sequel.connect(config)
  Sequel.extension :migration
end

# Подключаем все классы нашего фреймоворка
Dir[File.join(File.dirname(__FILE__), 'lib', '*.rb')].each {|file| require file }

# Подключаем все файлы нашего приложения
Dir[File.join(File.dirname(__FILE__), 'app', '**', '*.rb')].each {|file| require file }

# Если есть коннект к базе данных, то прогоняем миграции
if DB
  Sequel::Migrator.run(DB, File.join(File.dirname(__FILE__), 'app', 'db', 'migrations'))
end
```
Стоит обратить внимание на порядок выполнения подключаемых файлов. Сначала мы проверяем, есть ли база данных и подключаемся к ней, потому что для моделей нашего приложения важно, чтобы `DB`-коннект был определен. 

После чего мы вычитываем наш фреймворк, потому что иначе контроллеры из приложения не смогут найти к чему обратиться. Потом вычитываем папку `app`. Теперь определены и контроллеры и база данных. 

И после всего этого мы просто выполняем команду мигратора `run`. Определяем, что наши миграции будут лежать в папке `app/db/migrations/`.

Ну и на последок напишем две миграции. Одна создаст табличку постов, другая создаст несколько постов.

```ruby
# ./app/db/migrations/001_create_table_posts.rb
class CreateTablePosts < Sequel::Migration
  def up
    create_table :posts do
      primary_key :id
      column :title, :text
      String :content
      index :title
    end
  end

  def down
    drop_table :posts
  end
end

# ./app/db/migrations/002_add_some_posts.rb
class AddSomePosts < Sequel::Migration
  def up
    Post.create(
      title: 'Что такое Lorem Ipsum?',
      content: 'Lorem Ipsum - это текст-"рыба"...'
    )
    Post.create(
      title: 'Почему он используется?',
      content: 'Давно выяснено, что при оценке дизайна...'
    )
    Post.create(
      title: 'Откуда он появился?',
      content: 'Многие думают, что Lorem Ipsum - взятый с потолка...'
    )
  end

  def down
  end
end
```

Запускаем наше приложение и вот что получилось:
![Список постов](https://habrastorage.org/files/b4f/366/c8b/b4f366c8b58b44409aa16315f07df2a5.png)


## Оффтопик 2
На самом деле, всё это подключение значительно разрослось и я решил вынести его в отдельный файлик `lib/boot.rb`

```ruby
# ./lib/boot.rb
# Создаем коннект к базе
db_config_file = File.join(File.dirname(__FILE__), '..', 'app', 'database.yml')
if File.exist?(db_config_file)
  config  = YAML.load(File.read(db_config_file))
  DB = Sequel.connect(config)
  Sequel.extension :migration
end

# Подключаем все классы нашего фреймоворка
Dir[File.join(File.dirname(__FILE__), '..', 'lib', '*.rb')].each {|file| require file }

# Подключаем все файлы нашего приложения
Dir[File.join(File.dirname(__FILE__), '..', 'app', '**', '*.rb')].each {|file| require file }

# Если есть коннект к базе данных, то прогоняем миграции
if DB
  Sequel::Migrator.run(DB, File.join(File.dirname(__FILE__), '..', 'app', 'db', 'migrations'))
end

# Читаем роутинги
ROUTES = YAML.load(File.read(File.join(File.dirname(__FILE__), '..', 'app', 'routes.yml')))
```
Обратите внимание, что во всех путях добавилось `'..'`, это потому что сам boot.rb лежит в `lib`, а все пути раньше были относительно корня.


## That's all folks!
Да, на этом всё. Как видите, написать подобное приложение не так уж и сложно. А подобные упражнения дают понимание, как же оно всё таки работает.

Не могу отпустить вас без домашнего задания. Попробуйте реализовать что-нибудь из этого списка:

* У нас очень скудные роутинги — все запросы обрабатываются как GET. Было бы интересно посмотреть на реализацию полного RESTful приложения
* Поддержка лейаутов не была бы лишней для приложения
* Папка public могла бы отдавать ассеты, минуя создание контроллера  
* Как насчет реализовать интерактивную консоль на подобии `rails c`. Было бы здорово общаться с моделями через неё.
* Генераторы! Миграций, моделей, контроллеров, вьюшек — генерация этих файликов любима нами с rails-младенчества.
* Ну и суперзадача для суперпрограммиста: вынести всё это дело в гем, чтобы можно было одной командой сгенерировать приложение и заняться уже только наполнением папочки `app`.

Прикладываю ссылку на репозиторий с конечным вариантом. [Вуаля!](https://github.com/IvanShamatov/rails-like-app)

Дерзайте!